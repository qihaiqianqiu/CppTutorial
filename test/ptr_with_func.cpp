#include <iostream>
using namespace std;
// 值传递
void swap1(int a ,int b)
{
    int temp = a;
    a = b;
    b = temp;
}
//值传递的问题在于函数的两个形参位于某两个额外的地址上，与传入的两个变量都不相同，是两个变量在不同位置的副本

//地址传递
void swap2(int * p1, int *p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}
//地址传递则是创建了两个指针，指针必须以来所指向的对象而存在，所以锁定了传入了两个变量本身
//从空间上，两个多出来的指针其实和值传递中的两个多出来的副本占用等量的内存，temp也占用等量的内存，所以内存没有变化
//但是从结果上，地址传递交换的是两个指针所指地址的值，所以导致传入的两个变量在自身的地址上，也就是自身之间发生了交换
//可见，定义指针和定义变量的区别，定义指针依赖于已经存在的变量，也就锁定了已经存在的变量的位置

int main() {
int a = 10;
int b = 20;
swap1(a, b); // 值传递不会改变实参
swap2(&a, &b); //地址传递会改变实参
cout << "a = " << a << endl;
cout << "b = " << b << endl;
system("pause");
return 0;
}
