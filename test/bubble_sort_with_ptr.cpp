#include <iostream>
using namespace std;

// 另一种写法在参数里不用数组，直接用 int * array
// 仔细想来也有道理，数组的数据类型是定的，他在内存中的位置就等于pos【起始元素】 + 
// 所以一个数组是由起始元素 + 数据类型 + 元素数量唯一确定的
// 所以数组变量就等价于一个指针，因为指向起始元素的指针已经包含了数据类型 + 起始元素位置。通过迭代N次ptr++就可以实现完整的数组
// N * (delta)这部分就是体现动态分配的部分，提升代码效率
// 那为什么不所有的东西全都用指针来表示?
/*
C++ 中的这种设计是为了提供一种方便的方式来访问数组元素，并使代码更加简洁和灵活。这涉及到C++中数组和指针之间的紧密关系。

在C++中，一个指向数组的首元素的指针确实等价于这个数组变量，这是因为数组的名称本质上就是一个指向数组首元素的指针。这个设计的好处包括：

数组与指针的交互性: 这种设计允许数组和指针之间的无缝转换，使得你可以使用指针的方式来操作数组元素。这对于数组的遍历和访问元素非常方便。

函数参数传递: 通过将数组作为指针传递给函数，可以避免在函数参数中复制整个数组的开销。这使得函数能够更高效地处理大型数组。

动态内存分配: 这种等价性还有助于动态内存分配。你可以使用 new 操作符为数组分配内存，并得到一个指向数组首元素的指针。这允许你以指针的方式管理和操作动态分配的数组。

代码简洁性: 这种设计使得代码更加简洁和通用。你可以编写适用于不同数组的通用代码，而无需关心数组的大小或具体实现。

尽管这种等价性提供了很多便利性，但也需要小心使用，以避免指针操作中的潜在错误，如越界访问。在使用指针来操作数组时，始终确保不会超出数组的边界，以防止不可预测的行为和内存错误。
*/
void bubble_sort(int array[], int len){
    for(int * i = array; i <= &array[len-1]; i++){
        cout << "first ptr currently working on: " << *i << endl;
        for(int * k = array; k <= &array[len-1]; k++){
                    cout << *k << " ";
                }
                cout << endl << " ######### " << endl;
        // 一开始我写的*j=i++,导致很严重的错误，每次j都是和i同一个位置开始的，然后内层循环启动后*i右移了一格
        for(int * j = i+1; j <= &array[len-1]; j++){
            cout << "second ptr currently working on: " << *j << endl;
            for(int * k = array; k <= &array[len-1]; k++){
                    cout << *k << " ";
                }
                cout << endl << " --------- " << endl;
            if (*i > *j){
                int temp = *i;
                *i = *j;
                *j = temp;
            }
        }
    }
}
int main(){
    int arr[10] = {3,4,6,2,5,1,8,3,123,312};
    const int length = sizeof(arr) / sizeof(int);
    cout << "check length: " << length << endl;
    bubble_sort(arr, length);

    return 0;
}